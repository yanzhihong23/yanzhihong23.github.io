<!--
 * @Author: Hom Yan
 * @Date: 2019-05-20 20:36:04
 * @LastEditors: Hom Yan
 * @LastEditTime: 2019-06-12 11:58:09
 -->

# 用批萨餐厅类比事件循环

[Visualising the JavaScript Event Loop with a Pizza Restaurant analogy](https://dev.to/presto412/visualising-the-javascript-event-loop-with-a-pizza-restaurant-analogy-47a8) by `Priyansh Jain` on 2018-04-10

考虑一个**批萨**餐厅

现在我们有一个顾客下了两种类型的订单，
一个是很精细的订单：要一个批萨，橄榄浇头(1)，奶酪馅(2)，大尺寸的底(3)；
另一个是简单的：蛋黄酱(a)的蒜味面包(b)。

**厨师**接收到了订单就开始制作批萨，取一个大尺寸的底(3)，加上奶酪(2)，然后在加上橄榄浇头(1)。

同样的厨师还需要做蒜味面包。这时**经理**突然意识到餐馆里的蛋黄酱已经用完了。经理加了<i>取蛋黄酱</i> 的**任务**对话，并发送给了唯一有空的**差事男孩**，让他去取一些。

从技术上讲，如果要将订单放在一起并一起交付，客户将不得不等到一个差事男孩去五个街区外的超市，拿到蛋黄酱，并将其交给厨师完成订单。 但这是一家餐厅，顾客不需要立即将全部订单都交给他们。

厨师决定继续制作披萨，烘烤并将其发送给顾客。
这完成后，差事男孩带着蛋黄酱回来了，厨师拿一些蒜味面包（b），将蛋黄酱（a）加在上面，然后送给顾客。

**这里我们学到了什么与 JavaScript 有关？**

- 顾客的 <i>订单</i> (制作批萨 + 制作大蒜面包)就是 JavaScript 代码里的`functions(函数)`。
- 订单 <i>细节</i> 只是关于如何定制比萨饼和面包，它们可以被视为制作披萨内部的函数调用 - 订单是从上到下 - 浇头，馅料和大小。 这些细节基本上是调用堆栈的表示，它以相反的顺序执行所有这些事件。
- 餐厅 <i>没有蛋黄酱</i> - 这是一个称为`asynchronous function(异步函数)`的事件被触发，就是去超市取蛋黄酱。由于餐厅不需要将整个订单一起发送，因此他们以相反的顺序完成`call stack(调用栈)`中的任务，如故事中暗示的那样。
- 这里的 <i>经理</i> 就是**事件表** - 他的工作是按时间顺序跟踪发生的所有事故（事件）。
- <i>差事男孩</i> 就是**事件队列**，也就是说，如果他已经被要求去取东西并且有新物品需要取，则该物品必须等到差事男孩取回旧物品。
- <i>厨师</i> 就是**事件循环**，即不停的制作订单（执行所有函数）。
- <i>餐厅</i> 就是**浏览器**，不需要冻结直到所有内容都加载完成，也不需要等待一件事完成之后再去完成另一件。（不需要整个订单一起提供）

所以本质上，**事件循环**检查**调用栈**是否为空，如果是，则查看**事件队列**。如果队列里有东西，就把它加到调用栈并执行它。事件循环不断运行，直到结束（浏览器内容被加载/浏览器关闭）。 **事件表**跟踪已触发的所有事件，并将它们发送到要执行的事件队列。

这就是我尝试解释的事件循环，让我知道你是否觉得这个类比很有趣！
